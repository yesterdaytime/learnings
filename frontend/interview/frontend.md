# 浏览器事件循环

## 浏览器处理

    进程：是运行程序分配的内存块。
    线程：是运行代码的

    一个进程对应一个或多个线程，一个应用可能是单进程，也可能是多进程的

    浏览器是多进程，多线程的。在浏览器任务管理器中可以查看进程，其中包括浏览器进程，network进程，storage 进程，渲染进程。 渲染进程是每一个tab就有一个渲染进程，

    渲染进程模式可以通过命令改变。

    渲染主线程是无限循环的，会检测消息队列里是否有task, 有的话，执行，这里的task 包含同步，异步的task.

    渲染主线程处理的任务包括渲染过程中的所有处理task：

## 异步处理

    任务队列没有优先级，但消息队列有。

    在chrome中包含多个队列： 延时队列 < 交互队列 < 微队列 < 主线程

    延时队列： setTimeout, setInterval

    交互队列： click, zoom

    微队列： promise, mutation.


    js 能实现精准延时吗？

    不能，浏览器在延时进程在时间消耗完后，会将它加入队列中，如果队列中有其他优先级搞得任务，就会等其他的执行完后，执行延时函数。

    延时队列刷新是4ms，如果设置的不是4的倍数的值，会等几毫秒的。

# 浏览器渲染原理

    浏览器渲染过程： html 解析 -> css 解析 -> 布局 -> 分层 -> 绘制 -> 分块 -> 光栅化 -> 画出来

    html 解析： 将html解析成dom树， 解析过程中遇到css，会跳过解析，将css信息交由css 解析线程解析，遇到js会等待，可以用defer规避，defer会在加载完html后执行js， async可以规避加载js文件，不能规避执行

    css 解析： 将css 解析成css tree。

    布局： 合并dom tree与css tree，生成布局信息

    分层： 分层计算几何位置。will-change, z-index 等都会影响分层。

    绘制: 根据分层计算出的几何位置生成对应的绘制指令。绘制会启动一个合成线程和多个线程处理绘制的工作，线程绘制好后，会由合成线程进行合成。

    光栅化：根据绘制的结果，在gpu中进行布局颜色绘制成位图。

    画出来：根据光栅化后的位图，通过gpu调用显卡，在屏幕上画出来

    不直接调用显卡的原因是 光栅化是在渲染进程中，渲染进程是隔离的，无法直接调用


    任务分配：

    主线程: html parse - css parse - layout - layer - paint

    合成线程： --------------------------------------------- tiling - raster - draw

# 什么是 reflow?

    reflow 重新布局: 在js中改变css布局信息, 就会触发

# 什么是 repaint?

    重绘： 是改变布局和颜色等信息会触发

# 为什么 transform 效率高

    transform只影响最后的显示，不在渲染线程上。不会影响重绘和布局。

    下面两个示例中move1 在渲染进程卡死的情况下，不会卡死，move2会停止运动。

```
    @keyframes move1 {
        to {
            transform: translate(100px);
        }
    }

    @keyframes move2 {
        to {
            left: 100px;
        }
    }
```

# 还有哪些只影响 draw 的

    opacity, transform-style
